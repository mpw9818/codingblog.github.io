---
title: 原码补码反码
date: 2019-12-21 13:57:45
tags:
   原码补码
categories:
   计算机基础
---

## 原码、反码、补码

&emsp;&emsp;1.在计算机系统中，数值一律用补码来表示（存储）。用补码进行加法运算。

&emsp;&emsp;2.正数和0的补码、反码是本身原码,所以对于正数来说，可以理解为不存在反码和补码。
&emsp;&emsp;3.负数的反码：符号位不变，其他位取反。
&emsp;&emsp;4.负数的补码：对于负数而言， 补码 =  它的反码 + 1 。  
&emsp;&emsp;5.知道负数的补码，求原码：  原码 = 补码 -1 ，或对补码在取补码，就是先对补码取反码，然后将得到的数再 +1。

## byte的取值范围为什么是-128~127？
&emsp;&emsp;1.byte占用8位，每位用0或1表示，能够表示256(2^8)个数据。
&emsp;&emsp;2.这8位分为符号位（最高位）和数值位（剩余七位），符号位0表示正数，1表示负数。
&emsp;&emsp;3.按上一步的理解，容易得到（+127：0111 1111、+1：0000 0001、+0：0000 0000、-0：1000 0000、-1：1000 0001、-127：1111 1111），计算机底层定义了+0（0000 0000）就是0，那么“可怜的-0”又该何去何从呢？计算机遇到这个二进制该如何处理呢？总不能把这两个都对应0吧，这显然是资源浪费。
&emsp;&emsp;4.最后来解决这个-128为什么可以用1000 0000表示。这里我分析的是byte，它就8位。在无符号位的二进制中128的表示为1000 0000。有符号位的情况下byte好像无法表示+128或-128。如果我们假设现在byte不是占用8位，而是9位，最高位是符号位。那么-128就能够是1 1000 0000，其补码也是1 1000 0000，很神奇吧，一样的。-128的补码尾八位就是1000 0000。那就规定【1000 0000是-128的补码，且-128是没有原码和反码的，即不能利用1000 0000反推其原码和反码】。
&emsp;&emsp;5.你也可以简单就认为计算机规定了1000 0000就是-128，是一种人为设计没有什么道理可以言。

## byte by = (byte)130,结果是多少呢?

&emsp;&emsp;1、首先，java的正整数都会默认为int类型，所以130在强制转型之前，是int类型的数据
&emsp;&emsp;2、此时130的二进制码是（原码）：
     0000 0000 0000 0000 0000 0000 1000 0010
&emsp;&emsp;3、最高位是符号位，0代表正数1为负数，然而计算机运算的时候会事先将所有数据转成补码在运算
     而且正数的原码反码和补码都是一样，所以130的补码同样是：
     0000 0000 0000 0000 0000 0000 1000 0010
&emsp;&emsp;4、正整数的原码转成补码后，就开始强制转型了，因为byte的取值范围是 -2^7~2^7-1，所以byte类型的数据包含8个二进制位，最高一位属于正负符号位，所以不能计入取值范围
&emsp;&emsp;5、我们将int类型数强转为byte类型，就是直接把上面的二进制码超出第八位的所有数字都砍掉，因此，我们获得了强转之后的补码1000 0010
&emsp;&emsp;6、如果要获得这个补码的真实结果，我们还需要把它转化成原码，再计算它的十进制数值：
&emsp;&emsp;1000 0010的反码是：（所有位数减一，最高符号位不变）
&emsp;&emsp;1000 0001
&emsp;&emsp;以上反码的原码是：（所有位数取反，符号位不变）
&emsp;&emsp;1111 1110
&emsp;&emsp;根据以上原码计算二进制：
&emsp;&emsp;首位是1，是一个负数，得出结果为 -126